<link rel="import" href="../polymer/polymer.html">

<link rel="import" href="paper-datatable-column.html">

<link rel="import" href="../paper-checkbox/paper-checkbox.html">
<link rel="import" href="../paper-tooltip/paper-tooltip.html">

<script src="weakCache.js"></script>

<dom-module id="paper-datatable">
	<template>
		<style>
			:host {
				display: block;
				overflow: auto;
				@apply(--paper-font-common-base);
			}
			table{
				border-spacing: 0px;
				width:100%;
			}
			th{
				font-weight: 500;
				text-align:left;
				white-space: nowrap;
				@apply(--paper-font-common-base);
				-webkit-user-select: none;
				-ms-user-select: none;
				-moz-user-select: none;
				user-select: none;
				color: rgba(0,0,0, .54);
				font-size: 15px;
			}
			th:not([data-sortable]) iron-icon.sort{
				display: none;
			}
			th[data-sortable] iron-icon.sort {
				transition: transform .2s linear, width .2s linear;
				width: 0px;
			}
			th[data-sortable]{
				cursor: pointer;
				transition: padding-left .2s linear;
			}
			th[data-sortable][data-sorted]{
				padding-left: 4px;
				color: #333;
			}
			th[data-sortable][data-sorted] iron-icon{
				transform: rotate(-90deg) translate(1px, 0px);
				width: 20px;
			}
			th[data-sortable][data-sorted] iron-icon[data-direction='asc']{
				transform: rotate(90deg);
			}
			tr td, tr th{
				border-bottom: 1px solid var(--paper-datatable-divider-color, --divider-color);
				padding: 6px 28px 6px 28px;
				height: 41px;
			}
			th:not(:first-of-type){
				@apply(--paper-datatable-column-header);
			}
			tr th span{
				vertical-align: middle;
			}
			td.bound-cell{
				font-size: 16px;
				color: rgba(0,0,0,.87);
				@apply(--paper-datatable-cell);
			}
			td.bound-cell paper-input{
				--paper-input-container-input: {
					font-size: 16px;
				};
				--paper-input-container-underline: {
					display: none;
				}
			}
			td.bound-cell paper-input paper-icon-button {
				color: #757575;
				width: 32px;
				height: 32px;
				margin-top: -10px;
			}
			td.bound-cell paper-input[focused] {
					background: #fafafa;
					margin: -15px -20px;
					padding: 15px 20px;
					border-radius: 3px;
					box-shadow: 0 2px 2px 0 rgba(0, 0, 0, 0.14), 0 1px 5px 0 rgba(0, 0, 0, 0.12), 0 3px 1px -2px rgba(0, 0, 0, 0.2);
			}
			td.bound-cell paper-input[focused] paper-icon-button {
				display: none;
			}
			tr td:first-child, tr th:first-child{
				padding-left: 24px;
				padding-right: 0px;
				width:20px;
			}
			tr td:nth-of-type(2), tr th:nth-of-type(2){
				padding-left: 10px;
			}
			td:last-of-type, th:last-of-type{
				padding-right: 24px;
			}
			td:last-of-type{
				@apply(--paper-datatable-cell-last);
			}
			th:last-of-type{
				@apply(--paper-datatable-column-header-last);
			}
			tr[data-selected] td{
				background: var(--paper-datatable-row-selection-color, --paper-grey-100);
			}
			tr:hover td{
				background: var(--paper-datatable-row-hover-color, --paper-grey-200);
			}
			tbody tr:last-of-type td{
				border-bottom:none;
			}
			tbody td .array-item {
				display: inline-block;
				@apply(--paper-datatable-array-item);
			}
			tbody td .class-1 {
				@apply(--paper-datatable-class-1);
			}
			tbody td .class-2 {
				@apply(--paper-datatable-class-2);
			}
			tbody td .class-3 {
				@apply(--paper-datatable-class-3);
			}
			tbody td .class-4 {
				@apply(--paper-datatable-class-4);
			}
			tbody td .class-5 {
				@apply(--paper-datatable-class-5);
			}

			/* progress: */
			table tr.progress {

			}
			table tr.progress th paper-progress{
				height: 0px;
				transition: linear .2s height;
			}
			table tr.progress[data-progress] th paper-progress{
				height: 3px;
			}
			table tr.progress th{
				padding: 0px;
				height: 1px;
				border-bottom:0px;
			}
			table tr.progress th paper-progress{
				width: 100%;
			}
			paper-checkbox{
				@apply(--paper-datatable-checkbox);
			}
			th paper-checkbox{
				@apply(--paper-datatable-header-checkbox);
				--paper-checkbox-unchecked-color: var(--paper-datatable-header-checkbox-color, --primary-text-color);
			}
			.partialSelectionContainer{
				width:18px;
				height:18px;
				position:relative;
				display:flex;
				align-items:center;
				justify-content:center;
			}
			.partialSelection{
				width:6px;
				height:2px;
				background: var(--paper-datatable-header-checkbox-color, --primary-text-color);
				border-radius:1px;
				transition: transform .1s linear;
				transform: scale(0) rotate(-45deg);
			}
			.partialSelection[data-checked]{
				transform: scale(1) rotate(0deg);
			}
		</style>
		<div>
			<content select="paper-datatable-column"></content>
			<table>
				<thead>
					<tr>
						<template is="dom-if" if="{{selectable}}">
							<th style="min-width:30px;">
								<template is="dom-if" if="{{multiSelection}}">
									<div class="partialSelectionContainer" style="">
										<div class="partialSelection" data-checked$="[[_someChecked(selectedKeys.splices, data.*)]]"></div>
										<paper-checkbox on-tap="toggleAll" checked="[[_allChecked(selectedKeys.splices, data.*)]]" style="position:absolute;left:0px;top:0px;"></paper-checkbox>
									</div>
								</template>
							</th>
						</template>
						<template is="dom-repeat" items="{{_columns}}" as="column">
							<th data-sortable$="[[column.sortable]]" data-sorted$="[[_isEqual(column.property, sortProperty)]]" data-column="[[column]]" on-tap="_handleSort" style$="{{column._styleString}}">
								<iron-icon icon="arrow-forward" class="sort" data-direction$="[[sortDirection]]"></iron-icon>
								<span id="title">{{column.header}}</span>
								<template is="dom-if" if="[[column.tooltip]]">
									<paper-tooltip offset="-10" fit-to-visible-bounds>{{column.tooltip}}</paper-tooltip>
								</template>
							</th>
						</template>
					</tr>
					<tr class="progress" data-progress$="[[progress]]">
						<th colspan$="[[_numberOfColumnsPlusOne(_columns.splices)]]">
							<paper-progress indeterminate></paper-progress>
						</th>
					</tr>
				</thead>
				<tbody>
					<template id="rowRepeat" is="dom-repeat" items="[[_rowKeys]]" as="rowKey" on-dom-change="_restructureData">
						<!--
						 duplication due to https://github.com/David-Mulder/paper-datatable/issues/3 ...
						-->
						<template is="dom-if" if="{{multiSelection}}">
							<tr data-key$="{{rowKey}}" data-selected$="[[_isRowSelected(rowKey, selectedKeys.splices)]]" style$="{{_customRowStyle(rowKey)}}">
								<template is="dom-if" if="{{selectable}}">
									<td on-tap="_cellTapped">
										<!-- a somewhat specific 'hack' for <paper-datatable-card> :/ -->
										<!-- <template is="dom-if" if="{{!_isEqual(rowKey, '__new__')}}"> -->
											<paper-checkbox checked="[[_isRowSelected(rowKey, selectedKeys.splices)]]" on-change="_setSelection"></paper-checkbox>
										<!-- </template> -->
									</td>
								</template>
								<template is="dom-repeat" items="{{_columns}}" as="column" index-as="i" on-dom-change="_restructureData">
									<td data-column-i$="{{i}}" data-empty class="bound-cell" data-prop="{{column.property}}" on-tap="_cellTapped"></td>
								</template>
							</tr>
						</template>
						<template is="dom-if" if="{{!multiSelection}}">
							<tr data-key$="{{rowKey}}" data-selected$="[[_isRowSelected(rowKey, selectedKey)]]" style$="{{_customRowStyle(rowKey)}}">
								<template is="dom-if" if="{{selectable}}">
									<td on-tap="_cellTapped">
										<!-- a somewhat specific 'hack' for <paper-datatable-card> :/ -->
										<!-- <template is="dom-if" if="{{!_isEqual(rowKey, '__new__')}}"> -->
											<paper-checkbox checked="[[_isRowSelected(rowKey, selectedKey)]]" on-change="_setSelection"></paper-checkbox>
										<!-- </template> -->
									</td>
								</template>
								<template is="dom-repeat" items="{{_columns}}" as="column" index-as="i" on-dom-change="_restructureData">
									<td data-column-i$="{{i}}" data-empty class="bound-cell" data-prop="{{column.property}}" on-tap="_cellTapped"></td>
								</template>
							</tr>
						</template>
					</template>
				</tbody>
			</table>
		</div>
	</template>

	<script>

		(function () {
			'use strict';
			/* jshint eqeqeq : false */
			/*
The main element defining the data table. Data is provided to the `data` attribute as an array of objects and based on the `<paper-datatable-column>`'s cells will be generated for the respective properties.

Styling
===
The biggest difficulty is styling, because the way Polymer and the shadow DOM works it's incredibly hard to style elements that are hidden in the shadow DOM, as is the case for the cells. Dynamically setting up mixins isn't possible either however, so in the end the following compromise was reached:

Header cell and Row cell styling
---
It is possible to define a css string that will be applied to the header cell and all cells in a column like

	<paper-datatable-column [...] style="color:green;" cell-style="color:red;"></paper-datatable-column>

Which would make the header `green` and the content in each cell in the column `red`. This is especially useful to set a `min-width` on the header. There is also a convenience attribute `align='center'` to center columns (both the header and cells).

Events
===
There is a `row-tap` event for when a users taps on a row, and a `cell-tap` event for a specific cell. `cell-tap` can be listened for both on `paper-datatable` and `paper-datatable-column`.

ID: '__new__'
---
Note: the id value of `__new__` is reserved and can not be normally used. It's used by for example `<paper-datatable-card>` to support adding of new items.

Theming
===
Variables
---

 - `--paper-datatable-divider-color`: Divider color, defaults to `--divider-color`
 - `--paper-datatable-row-selection-color`: Color of selected row
 - `--paper-datatable-row-hover-color`: Color of hovered row

Mixins
---
 - `--paper-datatable-column-header`: Column header style applied to text headers
 - `--paper-datatable-cell`: Applied to all data cells
 - `--paper-datatable-array-item`: Only works when using the proper Shadow DOM and is applied to columns using the `array-display-prop` attribute.
 - `--paper-datatable-class-1`: Applied to any content in cells with `class='class-1'`.
 - `--paper-datatable-class-2`: Applied to any content in cells with `class='class-2'`.
 - `--paper-datatable-class-3`: Applied to any content in cells with `class='class-3'`.
 - `--paper-datatable-class-4`: Applied to any content in cells with `class='class-4'`.
 - `--paper-datatable-class-5`: Applied to any content in cells with `class='class-5'`.

@element paper-datatable
@demo demo/simple.html Simple clear example
@demo demo/paper-datatable.html Complex playground
			 */


			Polymer({

				is: 'paper-datatable',

				properties: {
					/**
					 * Read only array of all the `paper-datatable-column`'s
					 *
					 * @attribute _columns
					 * @type Array
					 */
					_columns: {
						type: Array
					},
					/**
					 * Array of objects containing the data to be shown in the table.
					 *
					 * @attribute data
					 * @type Array
					 * @required
					 */
					data: {
						type: Array,
						notify: true
					},
					/**
					 * Whether to show checkboxes on the left to allow row selection.
					 *
					 * @attribute selectable
					 * @type Boolean
					 * @default false
					 */
					selectable: {
						type: Boolean
					},
					/**
					 * Whether to allow selection of more than one row.
					 *
					 * @attribute multiSelection
					 * @type Boolean
					 * @default false
					 */
					multiSelection: {
						type: Boolean,
						value: false
					},
					/**
					 * If `multi-selection` then this contains an array of selected row keys.
					 *
					 * @attribute selectedIds
					 * @type Array
					 * @default []
					 */
					selectedKeys: {
						type: Array,
						notify: true,
						value: []
					},
					/**
					 * If `multi-selection` is off then this contains the key of the selected row.
					 *
					 * @attribute selectedId
					 * @type Object
					 */
					selectedKey: {
						type: Object,
						notify: true
					},
					/**
					 * If `multi-selection` is off then this contains the selected row.
					 *
					 * @attribute selectedId
					 * @type Object
					 */
					selectedItem: {
						type: Object,
						notify: true,
						computed: '_getByKey(selectedKey)'
					},
					/**
					 * If `multi-selection` is on then this contains an array of the selected rows.
					 *
					 * @attribute selectedId
					 * @type Object
					 */
					selectedItems: {
						type: Array,
						notify: true,
						computed: '_getSelectedItems(selectedKeys.splices)'
					},
					/**
					 * Property to sort on
					 *
					 * @attribute sortProperty
					 * @type String
					 * @default ''
					 */
					sortProperty: {
						type: String,
						value: ''
					},
					/**
					 * Direction to sort in
					 *
					 * @attribute sortDirection
					 * @type String
					 * @default 'asc'
					 */
					sortDirection: {
						type: String,
						value: 'asc'
					},
					_internalSortEnabled: {
						type: Boolean,
						value: false
					},
					_rowKeys: {
						type: Array
					},
					_cellInstances: {
						type: Object
					}
				},

				observers: [
					/*'restructureData(data.*, _columns.splices)',*/
					'_setRowKeys(data.splices)',
					'_setRowKeys(data.*)',
					'_notifyPathOnInstances(data.*)',
					'_internalSort(_internalSortEnabled, sortProperty, sortDirection)'

				],

				listeners: {
				},

				_setRowKeys: function(){
					var rowKeys = [];
					this._dataKeyCollection = Polymer.Collection.get(this.data);
					this.data.forEach(function(row){
						rowKeys.push(this._dataKeyCollection.getKey(row));
					}.bind(this));
					this.set("_rowKeys", rowKeys);
					this._internalSort();
				},

				_internalSort: function(){
					if(this._internalSortEnabled) {
						this._rowKeys.sort(function(a, b){
							if(this.sortDirection == "desc"){
								var c = a;
								a = b;
								b = c;
							}
							var valA = this._getByKey(a)[this.sortProperty] || "";
							var valB = this._getByKey(b)[this.sortProperty] || "";

							if(valA < valB) return -1;
							if(valA > valB) return 1;
							return 0;
						}.bind(this));
						this.set("_rowKeys", JSON.parse(JSON.stringify(this._rowKeys)));
					}
				},

				_isEqual: function(a, b){
					return a == b;
				},

				ready: function() {
					this.set('_columns', []);
					this.set('selectedKeys', []);
				},

				_restructureData: function(){
					if(Polymer.dom(this).querySelectorAll('paper-datatable-column').length === this._columns.length) {
						var rows = Polymer.dom(this.root).querySelectorAll('tbody tr');

						// loop through the rows
						for(var rowI=0; rowI<rows.length; rowI++){
							var row = rows[rowI];
							//find the data that belongs with the row
							var rowData = this.get('data.'+row.dataset.key);

							//get all cells in the row
							var cells = Polymer.dom(row).querySelectorAll('.bound-cell');
							for(var cellI=0;cellI<cells.length;cellI++){
								var cell = cells[cellI];
								if(cell.hasAttribute('data-empty') || cell.getAttribute('data-row-key') !== row.dataset.key){
									cell.removeAttribute('data-empty');

									var prop = this._columns[cellI].property;
									var data = rowData[prop];
									cell.setAttribute('data-row-key', row.dataset.key);

									if(this._columns[cellI].cellStyle.length > 0){
										cell.setAttribute('style', this._columns[cellI].cellStyle);
									}else{
										cell.setAttribute('style', '');
									}
									cell.style['text-align'] = this._columns[cellI].align;

									if(this._columns[cellI].template){
										var instance = this._columns[cellI].createCellInstance(
												rowData,
												row.dataset.key
										);
										cell.instance = instance;
										cell.innerHTML = '';
										cell.appendChild(instance.root);
									}else{
										cell.innerHTML = this._columns[cellI].formatValue(data)
										//cell.textContent = data;
									}
								}
							}
						}
					}

				},

				_notifyPathOnInstances: function(change){
					var path = change.path.split('.');
					//console.log('_notifyPathOnInstances', path, change);
					if(path.length >= 3){
						var object = path.shift();
						var rowKey = path.shift();
						if(path[0] == 'id'){
							console.warn('re-implement');
							// more `<paper-datatable-card>` specific hacks :/
							/*console.info('id property changed, new id is', change.value);
							var cells = Polymer.dom(this.root).querySelectorAll('tbody tr[data-id=\'__new__\'] td.bound-cell');
							for(var i=0; i<cells.length;i++) {
								var cell = cells[i];
								if(cell.instance){
									cell.instance.set('_dataId', change.value);
								}
							}
							return;*/
						}
						//var id = this.get('data.'+rowI+'.'+this.idProperty);
						//var id = this.data[rowI][this.idProperty];

						var row = Polymer.dom(this.root).querySelector('tbody tr[data-key=\''+rowKey+'\']');

						if(!row){
							console.error('critical failture');
							console.log('key', rowKey);
							return false;
						}

						var cells = row.querySelectorAll('td.bound-cell');
						for(var i=0; i<cells.length;i++){
							var cell = cells[i];
							var prop = cell.dataProp;

							if(prop == path[0]){
								if(cell.instance){
									var localPath = path.slice();
									localPath.shift();
									var instanceValuePath = ["value"].concat(localPath).join(".");
									//console.info(cell, "prop column value path", instanceValuePath, "to", change.value);
									cell.instance.notifyPath(instanceValuePath, change.value);
								}else{
									cell.innerHTML = this._columns[i].formatValue(change.value);
								}
							}
							if(cell.instance){
								var instancePath = ["item", path.join(".")].join(".");
								cell.instance.notifyPath(instancePath, change.value, true);
							}

						}
					}
				},

				toggleAll: function(){
					// todo: trigger event that will be caught by paper-datatable-card that will override this behaviour
					var allChecked = this._allChecked();
					this.data.forEach(function(item){
						if(allChecked){
							this.deselect(item);
						}else{
							this.select(item);
						}

					}.bind(this));
				},

				select: function(item, notify){
					notify = typeof notify === 'undefined' ? true : notify;

					var key = this._getKeyByItem(item);
					if(this.multiSelection){
						if(this.selectedKeys.indexOf(key) == -1){
							this.push('selectedKeys', key);
							if(notify) this.fire('selection-changed', {selected: [key]});
						}
					}else{
						this.set('selectedKey', key);
						if(notify) this.fire('selection-changed', {selected: [key]});
					}
				},

				deselect: function(item, notify){
					notify = typeof notify === 'undefined' ? true : notify;

					var key = this._getKeyByItem(item);
					if(this.multiSelection){
						var i = this.selectedKeys.indexOf(key);
						this.splice('selectedKeys', i, 1);
						if(notify) this.fire('selection-changed', {deselected: [key]});
					}else{
						if(notify) this.fire('selection-changed', {deselected: [key]});
						this.set('selectedKey', undefined);
					}
				},

				deselectAll: function(notify){
					if(this.multiSelection) {
						this.selectedItems.forEach(function(item){
							this.deselect(item, notify);
						}.bind(this))
					}else{
						this.deselect(this.selectedItem, notify);
					}
				},

				_allChecked: function(){
					var allChecked = true;
					this.data.forEach(function(item){
						var key = this._dataKeyCollection.getKey(item);
						if(this.selectedKeys.indexOf(key) == -1){
							allChecked = false;
						}
					}.bind(this));
					return allChecked && this.data.length > 0;
				},

				_someChecked: function(){
					return this.selectedKeys.length > 0 && !this._allChecked();
				},

				_isRowSelected: function(key){
					if(this.multiSelection){
						return this.selectedKeys.indexOf(key) > -1;
					}else{
						return this.selectedKey == key;
					}
				},

				_setSelection: function(ev){
					var key = ev.model.rowKey;
					if(ev.target.checked){
						if(this.multiSelection){
							this.push('selectedKeys', key);
							this.fire('selection-changed', {selected: [key]});
						}else{
							if(this.selectedKey){
								this.fire('selection-changed', {selected: [key], deselected: [this.selectedKey]});
							}else{
								this.fire('selection-changed', {selected: [key]});
							}
							this.selectedKey = key;
						}
					}else{
						if(this.multiSelection){
							this.splice('selectedKeys', this.selectedKeys.indexOf(key), 1);
							this.fire('selection-changed', {deselected: [key]});
						}else{
							this.fire('selection-changed', {deselected: [key]});
							this.selectedKey = null;
						}
					}
				},

				_toggleSelection: function(key){
					if(this.selectable){
						/*if(id == '__new__'){
							return false;
						}*/
						if(this.multiSelection){
							var checked = this.selectedKeys.indexOf(key) > -1;
							if(checked){
								this.splice('selectedKeys', this.selectedKeys.indexOf(key), 1);
								this.fire('selection-changed', {deselected: [key]});
							}else{
								this.push('selectedKeys', key);
								this.fire('selection-changed', {selected: [key]});
							}
						}else{
							var checked = this.selectedKey == key;
							if(checked){
								this.selectedKey = null;
								this.fire('selection-changed', {deselected: [key]});
							}else{
								if(this.selectedKey){
									this.fire('selection-changed', {selected: [key], deselected: [this.selectedKey]});
								}else{
									this.fire('selection-changed', {selected: [key]});
								}
								this.selectedKey = key;
							}
						}
					}
				},

				_handleSort: function(ev){

					var column = ev.model.column;
					if(column.sortable){
						this.set("sortDirection", this.sortDirection == 'asc' ? 'desc' : 'asc');
						var triggeredEvent = this.fire("sort", {sort: {
							property: this.sortProperty,
							direction: this.sortDirection
						}, column: column}, {cancelable: true});
						if(!triggeredEvent.defaultPrevented){
							this._internalSortEnabled = false;
							this.set("sortProperty", column.property);
							this._internalSortEnabled = true;
						}else{
							this.set("sortProperty", column.property);
							this._internalSortEnabled = false;
						}
					}

				},

				_cellTapped: function(ev){

					var PolymerEvent = Polymer.dom(ev);
					var path = PolymerEvent.path;
					for(var i=0;i<path.length;i++){
						if(path[i].nodeName.toLowerCase() == 'tr'){
							break;
						}
					}
					var rowModel = this.$.rowRepeat.modelForElement(path[i]);

					if(ev.model.column){
						ev.model.column.fire('cell-tap', {key:rowModel.rowKey, target:PolymerEvent.path[0], originalEvent: ev});
						this.fire('cell-tap', {column: ev.model.column, key:rowModel.rowKey, target:PolymerEvent.path[0], originalEvent: ev}, {});
					}

					var triggeredEvent = this.fire('row-tap', {key: rowModel.rowKey, originalEvent: ev}, {cancelable: true});
					if(!triggeredEvent.defaultPrevented){
						if(path[0].nodeName.toLowerCase() == 'td' || (ev.model.column && !ev.model.column.editable)){
							this._toggleSelection(rowModel.rowKey);
							ev.preventDefault();
						}
					}else{
						ev.preventDefault();
					}

				},

				_getKeyByItem: function(item){
					return this._dataKeyCollection.getKey(item);
				},

				_getByKey: function(key){
					if(key === null){
						return null;
					}
					if(typeof key === 'object'){
						return key.map(this._getByKey.bind(this));
					}
					return this.get('data.'+key);
				},

				_getSelectedItems: function(){
					return this._getByKey(this.selectedKeys);
				},

				_getIndexById: function(id){
					return console.warn('This function has been deprecated and removed.');
					/*return this.data.findIndex(function(item){
						return item[this.idProperty] == id;
					}.bind(this));*/
				},

				_numberOfColumnsPlusOne: function(){
					return this._columns.length + 1;
				},

				/*
				 Method that can be overwritten to apply a custom style to specific rows.
				 */
				customRowStyle: function(rowItem){

				},

				_customRowStyle: function(rowKey){
					return this.customRowStyle(this._getByKey(rowKey));
				}

			});
		})();
	</script>

</dom-module>
