<link rel="import" href="../polymer/polymer.html">

<link rel="import" href="paper-datatable-column.html">

<link rel="import" href="../paper-checkbox/paper-checkbox.html">
<link rel="import" href="../paper-tooltip/paper-tooltip.html">
<script src="weakCache.js"></script>

<dom-module id="paper-datatable">
	<template>
		<style>
			:host {
				display: block;
				overflow: auto;
			}
			table{
				border-spacing: 0px;
				width:100%;
			}
			th{
				color: #6D6E70;
				font-weight: normal;
				text-align:left;
				white-space: nowrap;
			}
			th iron-icon{
				transition: transform .2s linear;
			}
			th[data-direction='desc'] iron-icon{
				transform: rotate(180deg);
			}
			tr td, tr th{
				border-bottom: 1px solid var(--divider-color);
				padding: 6px;
				height: 41px;
			}
			tr td:first-child, tr th:first-child{
				padding-left: 24px;
				width:20px;
			}
			td:last-of-type, th:last-of-type{
				padding-right: 24px;
			}
			tr[data-selected] td{
				background: rgba(0,0,0,.04);
			}
			tbody tr:last-of-type td{
				border-bottom:none;
			}
			tbody td .array-item {
				display: inline-block;
				@apply(--paper-datatable-array-item);
			}
			tbody td .class-1 {
				@apply(--paper-datatable-class-1);
			}
			tbody td .class-2 {
				@apply(--paper-datatable-class-2);
			}
			tbody td .class-3 {
				@apply(--paper-datatable-class-3);
			}
			tbody td .class-4 {
				@apply(--paper-datatable-class-4);
			}
			tbody td .class-5 {
				@apply(--paper-datatable-class-5);
			}
			.link {
				cursor: pointer;
				@apply(--paper-datatable-class-link);
			}
		</style>
		<div>
			<content select="paper-datatable-column"></content>
			<table>
				<thead>
					<tr>
						<template is="dom-if" if="{{selectable}}">
							<th style="min-width:30px;">
								<template is="dom-if" if="{{multiSelection}}">
									<paper-checkbox on-tap="checkAll" checked="[[_allChecked(selectedIds.splices, data.splices)]]"></paper-checkbox>
								</template>
							</th>
						</template>
						<template is="dom-repeat" items="{{_columns}}" as="column">
							<th data-direction$="[[sortDirection]]" data-column="[[column]]" on-tap="_handleSort" style$="{{column._styleString}}">
								<template is="dom-if" if="[[_isEqual(column.property, sortProperty)]]">
									<iron-icon icon="arrow-drop-down"></iron-icon>
								</template>
								<span id="title">{{column.header}}</span>
								<template is="dom-if" if="[[column.tooltip]]">
									<paper-tooltip offset="-10">{{column.tooltip}}</paper-tooltip>
								</template>
							</th>
						</template>
					</tr>
				</thead>
				<tbody>
					<template is="dom-repeat" items="[[_rowIds]]" on-dom-change="_restructureData">
						<!--
						 https://github.com/David-Mulder/paper-datatable/issues/3 ...
						-->
						<template is="dom-if" if="{{multiSelection}}">
							<tr data-id$="{{item}}" data-selected$="[[_isRowSelected(item, selectedIds.splices)]]" on-tap="_rowTapped">
								<template is="dom-if" if="{{selectable}}">
									<td>
										<paper-checkbox checked="[[_isRowSelected(item, selectedIds.splices)]]" on-change="_setSelection"></paper-checkbox>
									</td>
								</template>
								<template is="dom-repeat" items="{{_columns}}" as="item" index-as="i" on-dom-change="_restructureData">
									<td data-column-i$="{{i}}" data-empty class="bound-cell" data-row-i="{{row-i}}" data-prop="{{item.property}}"></td>
								</template>
							</tr>
						</template>
						<template is="dom-if" if="{{!multiSelection}}">
							<tr data-id$="{{item}}" data-selected$="[[_isRowSelected(item, selectedId)]]" on-tap="_rowTapped">
								<template is="dom-if" if="{{selectable}}">
									<td>
										<paper-checkbox checked="[[_isRowSelected(item, selectedId)]]" on-change="_setSelection"></paper-checkbox>
									</td>
								</template>
								<template is="dom-repeat" items="{{_columns}}" as="item" index-as="i" on-dom-change="_restructureData">
									<td data-column-i$="{{i}}" data-empty class="bound-cell" data-row-i="{{row-i}}" data-prop="{{item.property}}"></td>
								</template>
							</tr>
						</template>
					</template>
				</tbody>
			</table>
		</div>
	</template>

	<script>

		(function () {
			'use strict';
			/* jshint eqeqeq : false */
			/*
The main element defining the data table. Data is provided to the `data` attribute as an array of objects and based on the `<paper-datatable-column>`'s cells will be generated for the respective properties.

Styling
===
The biggest difficulty is styling, because the way Polymer and the shadow DOM works it's incredibly hard to style elements that are hidden in the shadow DOM, as is the case for the cells. Dynamically setting up mixins isn't possible either however, so in the end the following compromise was reached:

Header cell and Row cell styling
---
It is possible to define a css string that will be applied to the header cell and all cells in a column like

	<paper-datatable-column [...] style="color:green;" cell-style="color:red;"></paper-datatable-column>

Which would make the header `green` and the content in each cell in the column `red`. This is especially useful to set a `min-width` on the header. There is also a convenience attribute `align='center'` to center columns (both the header and cells).


Mixins
---

 - `--paper-datatable-array-item`: Only works when using the proper Shadow DOM and is applied to columns using the `array-display-prop` attribute.
 - `--paper-datatable-class-1`: Applied to any content in cells with `class='class-1'`.
 - `--paper-datatable-class-2`: Applied to any content in cells with `class='class-2'`.
 - `--paper-datatable-class-3`: Applied to any content in cells with `class='class-3'`.
 - `--paper-datatable-class-4`: Applied to any content in cells with `class='class-4'`.
 - `--paper-datatable-class-5`: Applied to any content in cells with `class='class-5'`.
 - `--paper-datatable-class-link`: Applied to any content of type Link.

@element paper-datatable
@demo demo/paper-datatable.html
			 */


			Polymer({

				is: 'paper-datatable',

				/**
				 * Fired when the user makes a selection in the chart.
				 *
				 * @event link-clicked
				 * @param {object} detail The details about the clicked table item link.
				 */

				properties: {
					/**
					 * Read only array of all the `paper-datatable-column`'s
					 *
					 * @attribute _columns
					 * @type Array
					 */
					_columns: {
						type: Array
					},
					/**
					 * Array of objects containing the data to be shown in the table.
					 *
					 * @attribute data
					 * @type Array
					 * @required
					 */
					data: {
						type: Array,
						notify: true
					},
					/**
					 * Whether to show checkboxes on the left to allow row selection.
					 *
					 * @attribute selectable
					 * @type Boolean
					 * @default false
					 */
					selectable: {
						type: Boolean
					},
					/**
					 * Whether to allow selection of more than one row.
					 *
					 * @attribute multiSelection
					 * @type Boolean
					 * @default false
					 */
					multiSelection: {
						type: Boolean,
						value: false
					},
					/**
					 * If `multi-selection` then this contains an array of selected row id's.
					 *
					 * @attribute selectedIds
					 * @type Array
					 * @default []
					 */
					selectedIds: {
						type: Array,
						notify: true,
						value: []
					},
					/**
					 * If `multi-selection` is off then this contains the id of the selected row.
					 *
					 * @attribute selectedId
					 * @type Object
					 */
					selectedId: {
						type: Object,
						notify: true
					},
					/**
					 * If `multi-selection` is off then this contains the selected row.
					 *
					 * @attribute selectedId
					 * @type Object
					 */
					selectedItem: {
						type: Object,
						notify: true,
						computed: '_getById(selectedId)'
					},
					/**
					 * If `multi-selection` is on then this contains an array of the selected rows.
					 *
					 * @attribute selectedId
					 * @type Object
					 */
					selectedItems: {
						type: Array,
						notify: true,
						computed: '_getById(selectedIds)'
					},
					/**
					 * Property containing the `id` of every row. It is **important** this is available and set correctly for a lot of functionality.
					 *
					 * @attribute idProperty
					 * @type String
					 * @default 'id'
					 * @required
					 */
					idProperty: {
						type: String,
						value: 'id'
					},
					/**
					 * Property to sort on
					 *
					 * @attribute sortProperty
					 * @type String
					 * @default ''
					 */
					sortProperty: {
						type: String,
						value: ''
					},
					/**
					 * Direction to sort in
					 *
					 * @attribute sortDirection
					 * @type String
					 * @default 'asc'
					 */
					sortDirection: {
						type: String,
						value: 'asc'
					},
					_internalSortEnabled: {
						type: Boolean,
						value: false
					},
					_rowIds: {
						type: Array
					},
					_cellInstances: {
						type: Object
					}
				},

				observers: [
					/*'restructureData(data.*, _columns.splices)',*/
					'_notifyPathOnInstances(data.*)',
					'_internalSort(_internalSortEnabled, sortProperty, sortDirection)',
					'_setRowIds(data.splices)'
				],

				listeners: {
				},

				_setRowIds: function(){
					var rowIds = [];
					this.data.forEach(function(row){
						rowIds.push(row[this.idProperty]);
					}.bind(this));
					this.set("_rowIds", rowIds);
					this._internalSort();
				},

				_internalSort: function(){
					if(this._internalSortEnabled) {
						console.info("INTERNAL SORT on",this.sortProperty);
						this._rowIds.sort(function(a, b){
							if(this.sortDirection == "asc"){
								var c = a;
								a = b;
								b = c;
							}
							var valA = this._getById(a)[this.sortProperty] || "";
							var valB = this._getById(b)[this.sortProperty] || "";

							if(valA < valB) return -1;
							if(valA > valB) return 1;
							return 0;
						}.bind(this));
						this.set("_rowIds", JSON.parse(JSON.stringify(this._rowIds)));
					}
				},

				_isEqual: function(a, b){
					return a == b;
				},

				ready: function() {
					this.set('_columns', []);
					this.set('selectedIds', []);
					/*this.set('_sort', {
						property: this.idProperty,
						direction: 'asc'
					});*/
				},

				_restructureData: function(){
					if(Polymer.dom(this).querySelectorAll('paper-datatable-column').length === this._columns.length) {
						var rows = Polymer.dom(this.root).querySelectorAll('tbody tr');

						var findById = function(el){
							return el[this.idProperty] == row.dataset.id;
						}.bind(this);

						// loop through the rows
						for(var rowI=0; rowI<rows.length; rowI++){
							var row = rows[rowI];
							//find the data that belongs with the row
							var rowData = this.data.find(findById);

							//get all cells in the row
							var cells = Polymer.dom(row).querySelectorAll('.bound-cell');
							for(var cellI=0;cellI<cells.length;cellI++){
								var cell = cells[cellI];
								if(cell.hasAttribute('data-empty') || cell.getAttribute('data-row-id') !== row.dataset.id){
									cell.removeAttribute('data-empty');

									var prop = this._columns[cellI].property;
									var data = rowData[prop];
									cell.setAttribute('data-row-id', rowData[this.idProperty]);

									if(this._columns[cellI].cellStyle.length > 0){
										cell.setAttribute('style', this._columns[cellI].cellStyle);
									}else{
										cell.setAttribute('style', '');
									}
									cell.style['text-align'] = this._columns[cellI].align;

									if(this._columns[cellI].template){
										var instance = this._columns[cellI].createCellInstance(
												rowData,
												rowData[this.idProperty],
												prop
										);
										cell.instance = instance;
										cell.innerHTML = '';
										cell.appendChild(instance.root);
									}else{
										//cell.innerHTML = this._columns[cellI].formatValue(data)
										this._injectBoundHTML(this._columns[cellI].formatValue(data), cell);
										//cell.textContent = data;
									}
								}
							}
						}
					}

				},

				_getDataRowIFromID: function(id){
					return this.data.findIndex(function(el){
						return el[this.idProperty] == id;
					}.bind(this));
				},

				_notifyPathOnInstances: function(change){
					var path = change.path.split('.');
					if(path.length >= 3){
						var object = path.shift();
						var rowI = path.shift();
						var id = this.get("data."+rowI+"."+this.idProperty);
						//var id = this.data[rowI][this.idProperty];

						var row = Polymer.dom(this.root).querySelector('tbody tr[data-id=\''+id+'\']');

						var cells = row.querySelectorAll('td.bound-cell');
						for(var i=0; i<cells.length;i++){
							var cell = cells[i];
							var prop = cell.dataProp;

							if(prop == path[0]){
								if(cell.instance){
									var localPath = path.slice();
									localPath.shift();
									var instanceValuePath = ["value"].concat(localPath).join(".");
									//console.info(cell, "prop column value path", instanceValuePath, "to", change.value);
									cell.instance.notifyPath(instanceValuePath, change.value);
								}else{
									//cell.innerHTML = this._columns[i].formatValue(change.value);
									this._injectBoundHTML(this._columns[i].formatValue(change.value), cell);
								}
							}
							if(cell.instance){
								var instancePath = ["item", path.join(".")].join(".");
								cell.instance.notifyPath(instancePath, change.value, true);
							}

						}
					}
				},

				checkAll: function(){
					// todo: trigger event that will be caught by paper-datatable-card that will override this behaviour
					var allChecked = this._allChecked();
					this.data.forEach(function(item){
						var i = this.selectedIds.indexOf(item[this.idProperty]);
						if(allChecked){
							if(i > -1){
								this.splice('selectedIds', i, 1);
							}
						}else{
							if(i == -1){
								this.push('selectedIds', item[this.idProperty]);
							}
						}
					}.bind(this));
				},

				deselectAll: function(){
					if(this.multiSelection) {
						this.selectedIds.forEach(function(selectedId, i){
							this.splice('selectedIds', i, 1);
						}.bind(this));
					}else{
						this.set('selectedId', undefined);
					}
				},

				_allChecked: function(){
					var allChecked = true;
					this.data.forEach(function(item){
						if(this.selectedIds.indexOf(item[this.idProperty]) == -1){
							allChecked = false;
						}
					}.bind(this));
					return allChecked && this.data.length > 0;
				},

				_isRowSelected: function(id){
					if(this.multiSelection){
						return this.selectedIds.indexOf(id) > -1;
					}else{
						return this.selectedId == id;
					}
				},

				_setSelection: function(ev){
					var id = ev.model.item;
					if(ev.target.checked){
						if(this.multiSelection){
							this.push('selectedIds', id);
						}else{
							this.selectedId = id;
						}
					}else{
						if(this.multiSelection){
							this.splice('selectedIds', this.selectedIds.indexOf(id), 1);
						}else{
							this.selectedId = null;
						}
					}
				},

				_toggleSelection: function(id){
					if(this.selectable){
						if(this.multiSelection){
							var checked = this.selectedIds.indexOf(id) > -1;
							if(checked){
								this.splice('selectedIds', this.selectedIds.indexOf(id), 1);
							}else{
								this.push('selectedIds', id);
							}
						}else{
							var checked = this.selectedId == id;
							if(checked){
								this.selectedId = null;
							}else{
								this.selectedId = id;
							}
						}
					}
				},

				_handleSort: function(ev){

					var column = ev.model.column;
					if(column.sortable){
						this.set("sortDirection", this.sortDirection == 'asc' ? 'desc' : 'asc');
						var triggeredEvent = this.fire("sort", {sort: {
							property: this.sortProperty,
							direction: this.sortDirection
						}, column: column}, {cancelable: true});
						if(!triggeredEvent.defaultPrevented){
							this._internalSortEnabled = false;
							this.set("sortProperty", column.property);
							this._internalSortEnabled = true;
						}else{
							this.set("sortProperty", column.property);
							this._internalSortEnabled = false;
						}
					}

				},

				_rowTapped: function(ev){

					var triggeredEvent = this.fire('row-tap', {id: ev.model.item}, {cancelable: true})
					if(!triggeredEvent.defaultPrevented){
						if(ev.target.nodeName.toLowerCase() == 'td') {
							this._toggleSelection(ev.model.item);
							ev.preventDefault();
						}
					}else{
						ev.preventDefault();
					}

				},

				_getById: function(id){
					if(id === null){
						return null;
					}
					if(typeof id === 'object'){
						return id.map(this._getById.bind(this));
					}else{
						return this.data.find(function(item){
							return item[this.idProperty] == id;
						}.bind(this));
					}
				},

				_linkClicked: function(ev){
					var cell = ev.target.parentElement.parentElement;
					var details = {
						originalEvent: ev,
						cell: cell
					}
					this.fire('link-clicked', details, {cancelable: true})
					ev.preventDefault();
				},

				// http://stackoverflow.com/questions/30836412/polymer-1-0-injectboundhtml-alternative
				_injectBoundHTML: function(html, element){
					var that = this;
					var template = document.createElement('template', 'dom-bind');
					template._linkClicked = that._linkClicked;
					var doc = template.content.ownerDocument;
					var div = doc.createElement('div');
					div.innerHTML = html;
					template.content.appendChild(div);
					while (element.firstChild) {
							element.removeChild(element.firstChild);
					}
					element.appendChild(template);
				},

				getDataRow: function(rowId){
					return this.data[this._getDataRowIFromID(rowId)];
				}

			});
		})();
	</script>

</dom-module>
